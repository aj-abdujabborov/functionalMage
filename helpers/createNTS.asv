function [designMatrix] = computeDesignMatrix(eventList, runDuration, TR, varargin)
%CREATENTS Create a neural time series or design matrix from a run outline
%   runNTS = CREATENTS(runOutlines, runDur, TR, varargin). 
%   Specify parameter 'nCols' to be the number of columns to produce.
%   
%   To understand how runOutline works, see the help of fitvarhrfs. 
%
%   Note: The first column of the outline matrix (the "category" column)
%   indicates which column of the design matrix the corresponding event
%   will fall into. Thus, if you have arbitrary identities, the resultant
%   design matrix will have zero columns dispersed in-between. However, you
%   can clean this up after the fact.
%   
%   See also FITVARHRFS

%% Parse
keyboard;

p = inputParser;
addRequired(p, 'runOutline', @ismatrix);
addRequired(p, 'runDur', @(x) isvector(x) & length(x) == 1);
addRequired(p, 'TR', @(x) isvector(x) & length(x) == 1);
addParameter(p, 'nCols', [], @(x) (isvector(x) && length(x) == 1) || isempty(x));
parse(p, eventList, runDuration, TR, varargin{:});

% retrieve optional parameters
nColumns = p.Results.nCols;
if isempty(nColumns)
    nColumns = max(eventList(:, br.cat));
    if nColumns == 0
        error('I don''t know how many columns to have in the matrix.');
    end
end

%% Do
designMatrixResolution = 1/TR;
designMatrix = zeros(runDuration * designMatrixResolution, nColumns);

% Check
if ~(runDuration >= max(sum(eventList(:,[br.dur br.ons]), 2)))
    error('Timings in runOutline exceed provided run duration.');
end
if ~isequal(eventList(:,[br.dur br.ons]) ./ TR, floor(eventList(:,[br.dur br.ons]) ./ TR))
    error('Timings in runOutline are not divisible by TR.');
end

% Traverse over all rows in runOutline
for e = 1:size(eventList,1)
    if eventList(e, br.cat) < 1
        continue;
    end
    
    % Take br.ons and multiply by ntsResolution to find row at which to
    % place br.actity.
    fromRow = eventList(e, br.ons) * designMatrixResolution + 1;

    % Calculate how many rows this event occupies
    numRows = eventList(e, br.dur) * designMatrixResolution;

    % To which row must we go?
    toRow = fromRow + numRows - 1;
    
    % Get the column of activities
    tmpact = eventList(e, br.act) * ones(numRows, 1);

    % Place tmpact values into NTS into the column where it belongs
    belongPh = eventList(e, br.cat);
    designMatrix(fromRow:toRow, belongPh) = designMatrix(fromRow:toRow, belongPh) + tmpact;
end
    
